spat_df <- tmax %>%
distinct(lon, lat)  %>%   # select lon/lat only
arrange(lon, lat)       # sort ascending by lon/lat
spat_df
nrow(spat_avg)
m <- nrow(spat_avg)                  # number of stations
spat_df
m
Tmax
## ------------------------------------------------------------------------
X <- select(tmax, lon, lat, residuals, t) %>% # select columns
spread(t, residuals) %>%                 # make time-wide
select(-lon, -lat) %>%                   # drop coord info
t()                                      # make space-wide
tmax
tmax %>%
select(lon, lat, residuals, t) %>% # select columns
pivot_wider(t, residuals)
tmax %>%
select(lon, lat, residuals, t) %>% # select columns
spread(t, residuals)
## ------------------------------------------------------------------------
X <- tmax %>%
select(lon, lat, residuals, t) %>% # select columns
spread(t, residuals) %>%                 # make time-wide
select(-lon, -lat) %>%                   # drop coord info
t()                                      # make space-wide
X
## ------------------------------------------------------------------------
Lag0_cov <- cov(X, use = 'complete.obs')
Lag0_cov
Lag1_cov <- cov(X[-1, ], X[-nrow(X),], use = 'complete.obs')
Lag1_cov
## ------------------------------------------------------------------------
spat_df$n <- 1:nrow(spat_df)    # assign an index to each station
lim_lon <- range(spat_df$lon)   # range of lon coordinates
lon_strips <- seq(lim_lon[1],   # create 4 long. strip boundaries
lim_lon[2],
length = 5)
spat_df$lon_strip <- cut(spat_df$lon,     # bin the lon into
lon_strips,      # their respective bins
labels = FALSE,  # don't assign labels
include.lowest = TRUE) # include edges
## ------------------------------------------------------------------------
head(spat_df)   # print the first 6 records of spat_df
plot_cov_strips(Lag0_cov, spat_df)  # plot the lag-0 matrices
plot_cov_strips(Lag1_cov, spat_df)  # plot the lag-1 matrices
## ------------------------------------------------------------------------
data("STObj3", package = "STRbook")
STObj4 <- STObj3[, "1993-07-01::1993-07-31"]
## ------------------------------------------------------------------------
vv <- variogram(object = z~1 + lat, # fixed effect component
data = STObj4,      # July data
width = 80,         # spatial bin (80 km)
cutoff = 1000,      # consider pts < 1000 km apart
tlags = 0.01:6.01)  # 0 days to 6 days
STObj4
## ------------------------------------------------------------------------
vv <- variogram(object = z ~ 1 + lat, # fixed effect component
data = STObj4,      # July data
width = 80,         # spatial bin (80 km)
cutoff = 1000,      # consider pts < 1000 km apart
tlags = 0.01:6.01)  # 0 days to 6 days
## ------------------------------------------------------------------------
data("SSTlandmask", package = "STRbook")
data("SSTlonlat", package = "STRbook")
data("SSTdata", package = "STRbook")
## ------------------------------------------------------------------------
delete_rows <- which(SSTlandmask == 1)
SSTdata <- SSTdata[-delete_rows, 1:396]
## ------------------------------------------------------------------------
## Put data into space-wide form
Z <- t(SSTdata)
dim(Z)
## ------------------------------------------------------------------------
## First find the matrix we need to subtract:
spat_mean <- apply(SSTdata, 1, mean)
nT <- ncol(SSTdata)
## Then subtract and standardize:
Zspat_detrend <- Z - outer(rep(1, nT), spat_mean)
Zt <- 1/sqrt(nT - 1)*Zspat_detrend
## ------------------------------------------------------------------------
E <- svd(Zt)
## ------------------------------------------------------------------------
V <- E$v
colnames(E$v) <- paste0("EOF", 1:ncol(SSTdata)) # label columns
EOFs <- cbind(SSTlonlat[-delete_rows, ], E$v)
head(EOFs[, 1:6])
## ------------------------------------------------------------------------
TS <- data.frame(E$u) %>%            # convert U to data frame
mutate(t = 1:nrow(E$u)) %>%    # add a time field
gather(EOF, PC, -t)            # put columns (except time)
## ------------------------------------------------------------------------
TS$nPC <- TS$PC * sqrt(nT-1)
## ------------------------------------------------------------------------
ggplot(EOFs) + geom_tile(aes(x = lon, y = lat, fill = EOF1)) +
fill_scale(name = "degC") + theme_bw() +
xlab("Longitude (deg)") + ylab("Latitude (deg)")
## ------------------------------------------------------------------------
nEOF <- 10
EOFset1 <- E$u[1:(nT-7), 1:nEOF] * sqrt(nT - 1)
EOFset2 <- E$u[8:nT, 1:nEOF] * sqrt(nT - 1)
## ------------------------------------------------------------------------
cc <- cancor(EOFset1, EOFset2)  # compute CCA
options(digits = 3)             # print to three d.p.
print(cc$cor[1:5])              # print
print(cc$cor[6:10])
## ------------------------------------------------------------------------
CCA_df <- data.frame(t = 1:(nT - 7),
CCAvar1 = (EOFset1 %*% cc$xcoef[,1])[,1],
CCAvar2 = (EOFset2 %*% cc$ycoef[,1])[,1])
## ------------------------------------------------------------------------
t_breaks <- seq(1, nT, by = 60)     # breaks for x-labels
year_breaks <- seq(1970,2002,by=5)  # labels for x-axis
g <- ggplot(CCA_df) +
geom_line(aes(t, CCAvar1), col = "dark blue") +
geom_line(aes(t, CCAvar2), col = "dark red") +
scale_x_continuous(breaks = t_breaks, labels = year_breaks) +
ylab("CCA variables") + xlab("Year") + theme_bw()
g
## ------------------------------------------------------------------------
EOFs_CCA <- EOFs[,1:4] # first two columns are lon-lat
EOFs_CCA[,3] <- c(as.matrix(EOFs[,3:12]) %*% cc$xcoef[,1])
EOFs_CCA[,4] <- c(as.matrix(EOFs[,3:12]) %*% cc$ycoef[,1])
library(dplyr)
library(mgcv)
library(ggplot2)
library(cowplot)
n= 100
dat = data_frame(x =seq(-3,3,length=n),
y= rnorm(n, cos(x*pi),0.2),
in_sample = ifelse(abs(x)<1,1,0),
extrapolate_val = factor(sign(x)*as.numeric(abs(x)>1)))
dat$y = ifelse(dat$in_sample, dat$y,0)
model_m1 = gam(y~s(x,m=1,k=20), weights = in_sample,data=dat)
model_m2 = gam(y~s(x,m=2,k=20), weights = in_sample,data=dat)
predict_m1 = predict(model_m1,dat,se=T)
predict_m2 = predict(model_m2,dat,se=T)
predict_data = rbind(dat, dat)
predict_data$model = rep(c("tprs m=1","tprs m=2"),each=n)
predict_data$fit = as.numeric(c(predict_m1$fit,predict_m2$fit))
predict_data$se.fit = as.numeric(c(predict_m1$se.fit,predict_m2$se.fit))
in_sample_plot = ggplot(aes(x=x, y=fit), data=filter(predict_data, in_sample==1))+
geom_line()+
geom_rug(sides="b")+
geom_point(aes(y=y))+
geom_ribbon(aes(ymin =fit-2*se.fit, ymax=fit+2*se.fit),
alpha=0.25)+
theme_bw()+
facet_grid(model~.)
out_sample_plot = ggplot(aes(x=x, y=fit,color=extrapolate_val
,fill =extrapolate_val), data=predict_data)+
geom_line(group=1)+
geom_rug(sides="b")+
scale_color_manual(values = c("darkgrey","black","darkgrey"))+
scale_fill_manual(values = c("darkgrey","black","darkgrey"))+
geom_ribbon(aes(ymin =fit-2*se.fit, ymax=fit+2*se.fit),
alpha=0.33,color=NA)+
facet_grid(model~.,scales="free_y")+
theme_bw()+
theme(legend.position ="none")
print(in_sample_plot)
print(out_sample_plot)
library("CCA")
library("dplyr")
library("ggplot2")
library("gstat")
library("sp")
library("spacetime")
library("STRbook")
library("tidyr")
library("grid")
library("gridExtra")
## ------------------------------------------------------------------------
set.seed(1)
## -----------------------------------------------------------
data("NOAA_df_1990", package = "STRbook")
Tmax <- filter(NOAA_df_1990,     # subset the data
proc == "Tmax" &   # only max temperature
month %in% 5:9 &   # May to September
year == 1993)      # year of 1993
Tmax$t <- Tmax$julian - 728049   # create a new time variable
## -----------------------------------------------------------
spat_av <- group_by(Tmax, lat, lon) %>%    # group by lon-lat
summarise(mu_emp = mean(z))     # mean for each lon-lat
## ------------------------------------------------------------------------
lat_means <- ggplot(spat_av) +
geom_point(aes(lat, mu_emp)) +
xlab("Latitude (deg)") +
ylab("Maximum temperature (degF)") + theme_bw()
lon_means <- ggplot(spat_av) +
geom_point(aes(lon, mu_emp)) +
xlab("Longitude (deg)") +
ylab("Maximum temperature (degF)") + theme_bw()
## ------------------------------------------------------------------------
Tmax_av <- group_by(Tmax, date) %>%
summarise(meanTmax = mean(z))
## ------------------------------------------------------------------------
gTmaxav <-
ggplot() +
geom_line(data = Tmax,aes(x = date, y = z, group = id),
colour = "blue", alpha = 0.04) +
geom_line(data = Tmax_av, aes(x = date, y = meanTmax)) +
xlab("Month") + ylab("Maximum temperature (degF)") +
theme_bw()
## ------------------------------------------------------------------------
lm1 <- lm(z ~ lat + t + I(t^2), data = Tmax) # fit a linear model
Tmax$residuals <- residuals(lm1)             # store the residuals
## ------------------------------------------------------------------------
spat_df <- filter(Tmax, t == 1) %>% # lon/lat coords of stations
select(lon, lat)  %>%   # select lon/lat only
arrange(lon, lat)       # sort ascending by lon/lat
m <- nrow(spat_av)                  # number of stations
## ------------------------------------------------------------------------
X <- select(Tmax, lon, lat, residuals, t) %>% # select columns
spread(t, residuals) %>%                 # make time-wide
select(-lon, -lat) %>%                   # drop coord info
t()                                      # make space-wide
## ------------------------------------------------------------------------
Lag0_cov <- cov(X, use = 'complete.obs')
Lag1_cov <- cov(X[-1, ], X[-nrow(X),], use = 'complete.obs')
## ------------------------------------------------------------------------
spat_df$n <- 1:nrow(spat_df)    # assign an index to each station
lim_lon <- range(spat_df$lon)   # range of lon coordinates
lon_strips <- seq(lim_lon[1],   # create 4 long. strip boundaries
lim_lon[2],
length = 5)
spat_df$lon_strip <- cut(spat_df$lon,     # bin the lon into
lon_strips,      # their respective bins
labels = FALSE,  # don't assign labels
include.lowest = TRUE) # include edges
## ------------------------------------------------------------------------
head(spat_df)   # print the first 6 records of spat_df
plot_cov_strips(Lag0_cov, spat_df)  # plot the lag-0 matrices
plot_cov_strips(Lag1_cov, spat_df)  # plot the lag-1 matrices
## ------------------------------------------------------------------------
data("STObj3", package = "STRbook")
STObj4 <- STObj3[, "1993-07-01::1993-07-31"]
## ------------------------------------------------------------------------
vv <- variogram(object = z~1 + lat, # fixed effect component
data = STObj4,      # July data
width = 80,         # spatial bin (80 km)
cutoff = 1000,      # consider pts < 1000 km apart
tlags = 0.01:6.01)  # 0 days to 6 days
## ------------------------------------------------------------------------
vv <- variogram(object = z ~ 1 + lat, # fixed effect component
data = STObj4,      # July data
width = 80,         # spatial bin (80 km)
cutoff = 1000,      # consider pts < 1000 km apart
tlags = 0.01:6.01)  # 0 days to 6 days
?variogram
?variogram
?variogramST
## ------------------------------------------------------------------------
data("STObj3", package = "STRbook")
STObj3
STObj4
?variogram
## ------------------------------------------------------------------------
vv <- gstat::variogram(object = z ~ 1 + lat, # fixed effect component
data = STObj4,      # July data
width = 80,         # spatial bin (80 km)
cutoff = 1000,      # consider pts < 1000 km apart
tlags = 0.01:6.01)  # 0 days to 6 days
## ------------------------------------------------------------------------
vv <- STRbook::variogram(object = z ~ 1 + lat, # fixed effect component
data = STObj4,      # July data
width = 80,         # spatial bin (80 km)
cutoff = 1000,      # consider pts < 1000 km apart
tlags = 0.01:6.01)  # 0 days to 6 days
?variogram
??variogram
library(pacman) # for loading packages
p_load(tidyverse, lubridate, here, fs, vroom, furrr, janitor)
plan(multicore) # for furrr function
# find all the csv files
csv_list <- dir_ls(
here::here('converted_argos'),
glob = '*csv')
csv_list
# read and combine
tbl <- future_map_dfr(csv_list, readr::read_csv, .id = 'path')
# clean names
tbl <- tbl %>% clean_names()
# Select relevant variables
tbl <- tbl %>%
mutate(tag_id = str_sub(path, start = -23, end = -18)) %>%
mutate(date = dmy(date)) %>%
select(tag_id, crc, date, time, latitude, longitude, fix) %>%
arrange(tag_id, date) %>%
distinct()
tbl %>% print(n=Inf)
# Filter out bad points here and duplicates
locs <- tbl %>%
filter(crc !="Fail") %>%
filter(fix %in% c("3D", "2D", "A1", "A2", "A3")) %>% # select GPS locations and higher quality Argos location classes
select(-crc) %>% # this allows you remove duplicates labeled with different CRCs (OK, OK(corrected))
distinct()
locs %>% print(n=Inf)
# Rename fix type
locs <- locs %>%
mutate(type = case_when(
fix %in% c("3D", "2D") ~ "GPS",
fix %in% c('A1', 'A2', 'A3') ~ 'Argos')) %>%
mutate(fix = str_c(fix, type, sep = ' ')) %>%
select(-type)
locs %>% print(n=Inf)
# Sort it and create fix # by TagID and date
locs <- locs %>%
arrange(tag_id, date) %>%
mutate(sequence = sequence(rle(.$tag_id)$lengths))
locs %>% print(n=Inf)
# Sort it and create fix # by TagID and date
locs <- locs %>%
arrange(tag_id, date) %>%
mutate(sequence = sequence(rle(.$tag_id)$lengths))
locs %>% print(n=Inf)
appended_date <- Sys.Date()
# Write to csv file by date more data was added
vroom_write(locs, str_c(here::here('output_data'), '/', 'amke_locations', '_', appended_date, '.csv'), delim = ",")
library(sf)
library(mapview)
# find the most recent file, which is last in the list due to sorting
output_data_directory <- dir_ls(here::here('output_data'))
last_file_loc <- length(output_data_directory)
output_data_directory[last_file_loc]
# read in file
locs <- read_csv(output_data_directory[last_file_loc])
locs %>% print(n=Inf)
# change Argos code to 3 digit ID to make leaflet plotting cleaner
locs <- locs %>%
mutate(tag_id = str_sub(tag_id, start = 4, end = 6))
locs
# remove microwave data
locs <- locs %>%
filter(tag_id != '521' & tag_id != '522')
locs %>% print(n=Inf)
mapview_locs <- locs
# convert to sf object
sf_locs <- sf::st_as_sf(
mapview_locs, coords = c("longitude","latitude")
) %>%
sf::st_set_crs(4326)
# create lines
sf_lines <- sf_locs %>%
dplyr::arrange(tag_id, date) %>%
dplyr::group_by(tag_id) %>%
dplyr::summarise(do_union = FALSE) %>%
sf::st_cast("MULTILINESTRING")
str(sf_lines)
# create points
sf_points <- sf_locs %>%
dplyr::arrange(tag_id, date) %>%
dplyr::group_by(tag_id) %>%
#dplyr::summarise(do_union = FALSE) %>%
sf::st_cast("MULTIPOINT")
# line map
map1 <- sf_lines %>%
mapview(
map.types = c(
"CartoDB.Positron",
"Esri.WorldImagery",
"Stamen.Terrain",
"OpenStreetMap.Mapnik"
),
#zcol = "tag_id",
#burst = TRUE,
legend = FALSE,
homebutton = FALSE
)
# point map
map2 <- sf_points %>%
mapview(
map.types = c("CartoDB.Positron", "Esri.WorldImagery", "Stamen.Terrain", "OpenStreetMap.Mapnik"),
#zcol = "tag_id",
#burst = TRUE,
legend = FALSE,
homebutton = FALSE
)
# combine together
combinedMap <- map1 + map2
combinedMap
library(pacman) # for loading packages
p_load(tidyverse, lubridate, here, fs, vroom, furrr, janitor)
plan(multicore) # for furrr function
# find all the csv files
csv_list <- dir_ls(
here::here('converted_argos'),
glob = '*csv')
csv_list
# read and combine
tbl <- future_map_dfr(csv_list, readr::read_csv, .id = 'path')
# clean names
tbl <- tbl %>% clean_names()
# Select relevant variables
tbl <- tbl %>%
mutate(tag_id = str_sub(path, start = -23, end = -18)) %>%
mutate(date = dmy(date)) %>%
select(tag_id, crc, date, time, latitude, longitude, fix) %>%
arrange(tag_id, date) %>%
distinct()
tbl %>% print(n=Inf)
library(pacman) # for loading packages
p_load(tidyverse, lubridate, here, fs, vroom, furrr, janitor)
plan(multicore) # for furrr function
# find all the csv files
csv_list <- dir_ls(
here::here('converted_argos'),
glob = '*csv')
csv_list
# read and combine
tbl <- future_map_dfr(csv_list, readr::read_csv, .id = 'path')
# clean names
tbl <- tbl %>% clean_names()
# Select relevant variables
tbl <- tbl %>%
mutate(tag_id = str_sub(path, start = -23, end = -18)) %>%
mutate(date = dmy(date)) %>%
select(tag_id, crc, date, time, latitude, longitude, fix) %>%
arrange(tag_id, date) %>%
distinct()
tbl %>% print(n=Inf)
# Filter out bad points here and duplicates
locs <- tbl %>%
filter(crc !="Fail") %>%
filter(fix %in% c("3D", "2D", "A1", "A2", "A3")) %>% # select GPS locations and higher quality Argos location classes
select(-crc) %>% # this allows you remove duplicates labeled with different CRCs (OK, OK(corrected))
distinct()
locs %>% print(n=Inf)
# Rename fix type
locs <- locs %>%
mutate(type = case_when(
fix %in% c("3D", "2D") ~ "GPS",
fix %in% c('A1', 'A2', 'A3') ~ 'Argos')) %>%
mutate(fix = str_c(fix, type, sep = ' ')) %>%
select(-type)
locs %>% print(n=Inf)
# Sort it and create fix # by TagID and date
locs <- locs %>%
arrange(tag_id, date) %>%
mutate(sequence = sequence(rle(.$tag_id)$lengths))
locs %>% print(n=Inf)
# Sort it and create fix # by TagID and date
locs <- locs %>%
arrange(tag_id, date) %>%
mutate(sequence = sequence(rle(.$tag_id)$lengths))
locs %>% print(n=Inf)
appended_date <- Sys.Date()
# Write to csv file by date more data was added
vroom_write(locs, str_c(here::here('output_data'), '/', 'amke_locations', '_', appended_date, '.csv'), delim = ",")
library(sf)
library(mapview)
# find the most recent file, which is last in the list due to sorting
output_data_directory <- dir_ls(here::here('output_data'))
last_file_loc <- length(output_data_directory)
output_data_directory[last_file_loc]
# read in file
locs <- read_csv(output_data_directory[last_file_loc])
locs %>% print(n=Inf)
# change Argos code to 3 digit ID to make leaflet plotting cleaner
locs <- locs %>%
mutate(tag_id = str_sub(tag_id, start = 4, end = 6))
locs
# remove microwave data
locs <- locs %>%
filter(tag_id != '521' & tag_id != '522')
locs %>% print(n=Inf)
mapview_locs <- locs
# convert to sf object
sf_locs <- sf::st_as_sf(
mapview_locs, coords = c("longitude","latitude")
) %>%
sf::st_set_crs(4326)
# create lines
sf_lines <- sf_locs %>%
dplyr::arrange(tag_id, date) %>%
dplyr::group_by(tag_id) %>%
dplyr::summarise(do_union = FALSE) %>%
sf::st_cast("MULTILINESTRING")
str(sf_lines)
# create points
sf_points <- sf_locs %>%
dplyr::arrange(tag_id, date) %>%
dplyr::group_by(tag_id) %>%
#dplyr::summarise(do_union = FALSE) %>%
sf::st_cast("MULTIPOINT")
# line map
map1 <- sf_lines %>%
mapview(
map.types = c(
"CartoDB.Positron",
"Esri.WorldImagery",
"Stamen.Terrain",
"OpenStreetMap.Mapnik"
),
#zcol = "tag_id",
#burst = TRUE,
legend = FALSE,
homebutton = FALSE
)
# point map
map2 <- sf_points %>%
mapview(
map.types = c("CartoDB.Positron", "Esri.WorldImagery", "Stamen.Terrain", "OpenStreetMap.Mapnik"),
#zcol = "tag_id",
#burst = TRUE,
legend = FALSE,
homebutton = FALSE
)
# combine together
combinedMap <- map1 + map2
combinedMap
